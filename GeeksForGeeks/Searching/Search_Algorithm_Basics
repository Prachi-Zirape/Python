{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "9986e02d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Element not in arr\n"
     ]
    }
   ],
   "source": [
    "#Date 09/13/22\n",
    "#Linear-Itrative\n",
    "arr= [10, 20, 80, 30, 60, 50,110, 100, 130, 170]\n",
    "x = 1110\n",
    "\n",
    "for i in arr:\n",
    "    if i==x:\n",
    "        print(arr.index(x))\n",
    "        break\n",
    "    elif i==arr[-1] and i!=x:\n",
    "        print(\"Element not in arr\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "7f5e4829",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "6"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Linear-Recursive\n",
    "arr= [10, 20, 80, 30, 60, 50,110, 100, 130, 170]\n",
    "x = 110\n",
    "arr_size=len(arr)-1\n",
    "\n",
    "def rec_linear(arr,x,arr_size):\n",
    "    if arr_size==0:\n",
    "        return -1\n",
    "    elif arr_size==1 and arr[0]!=x:\n",
    "        return -1\n",
    "    elif arr[arr_size]==x:\n",
    "        return arr_size\n",
    "    else:\n",
    "        return rec_linear(arr,x,arr_size-1)\n",
    "rec_linear(arr,x,arr_size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "702b08c5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Found At Index 2\n"
     ]
    }
   ],
   "source": [
    "#Date 09/16/22\n",
    "#Binary-Iterative\n",
    "def bin_search(arr,x):\n",
    "    high=len(arr)-1\n",
    "    low=0\n",
    "    \n",
    "    while (high-low>1):  #where high always right to low\n",
    "        \n",
    "        mid=(low+high)//2\n",
    "        #print(high,low)\n",
    "        \n",
    "        if arr[mid]<x:\n",
    "            low=mid+1\n",
    "           # print(\"l\",mid,low)\n",
    "            \n",
    "        else:           #else if condition would not work\n",
    "            high=mid\n",
    "            #print(\"h\",mid,high)        \n",
    "    \n",
    "    if arr[low] == x:\n",
    "        print(\"Found At Index\", low)\n",
    "    elif arr[high] == x:\n",
    "        print(\"Found At Index\", high)\n",
    "    else:\n",
    "        print(\"Not Found\")\n",
    "\n",
    "x=4\n",
    "arr=[1, 3, 4, 5, 6, 7, 8, 9, 10]\n",
    "(bin_search(arr,x))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "48a1b959",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-1\n"
     ]
    }
   ],
   "source": [
    "def rec_binary(arr,x,low,high):\n",
    "    \n",
    "    #base case2\n",
    "    if  high>=low:\n",
    "        \n",
    "       # mid=low + (high-low) //2\n",
    "        mid=(low + high) //2\n",
    "       # print(mid)\n",
    "        \n",
    "        if arr[mid]==x:\n",
    "            return mid\n",
    "        \n",
    "        # If x is smaller, x is in left subarray\n",
    "        elif arr[mid]>x:\n",
    "            #print(\"1::\",low,high)\n",
    "            return rec_binary(arr,x,low,mid-1)\n",
    "        \n",
    "        # If x is larger, x is in right subarray\n",
    "        else:\n",
    "            #print(\"2::\",low,high)\n",
    "            return rec_binary(arr,x,mid+1,high)\n",
    "        \n",
    "    else:\n",
    "        return -1\n",
    "\n",
    "x=90\n",
    "arr=[2, 3, 4, 5, 6, 7, 8, 9, 10]\n",
    "low=0\n",
    "high=len(arr)-1\n",
    "print(rec_binary(arr,x,low,high))   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "3c3d4dc1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "10.0\n"
     ]
    }
   ],
   "source": [
    "#Jump Search\n",
    "import math\n",
    "def jumpSearch(arr,x,n):\n",
    "    step=math.sqrt(n)\n",
    "    \n",
    "    prev=0\n",
    "    # Finding the block where element is\n",
    "    # present (if it is present)\n",
    "    #binary search block\n",
    "    while arr[int(min(step,n)-1)]<x:\n",
    "        prev=step\n",
    "        step+=math.sqrt(n)   #steps increased by block\n",
    "        if prev>=n:\n",
    "            return -1\n",
    "        \n",
    "    #linear search block\n",
    "    while arr[int(prev)]<x:\n",
    "        prev+=1\n",
    "        \n",
    "        # If we reached next block or end\n",
    "        # of array, element is not present.\n",
    "        if prev==min(step,n):\n",
    "            return -1\n",
    "        \n",
    "    if arr[int(prev)]==x:\n",
    "        return prev\n",
    "        \n",
    "    return -1\n",
    "\n",
    "arr = [ 0, 1, 1, 2, 3, 5, 8, 13, 21,\n",
    "    34, 55, 89, 144, 233, 377, 610 ]\n",
    "x = 55\n",
    "n = len(arr)\n",
    " \n",
    "# Find the index of 'x' using Jump Search\n",
    "index = jumpSearch(arr, x, n)\n",
    "        \n",
    "print(index)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "40b5ea6e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Element found at index 4\n"
     ]
    }
   ],
   "source": [
    "#Date-09/17/22\n",
    "#interpolation Search\n",
    "def interpolation_search(arr,lo,hi,x):\n",
    "    if (lo<=hi and x>=arr[lo] and x<=arr[hi]):\n",
    "        pos=lo+((hi-lo)//(arr[hi]-arr[lo])*(x-arr[lo]))\n",
    "        \n",
    "        if arr[pos]==x:\n",
    "            return pos\n",
    "        \n",
    "         # If x is larger, x is in right subarray\n",
    "        if arr[pos]<x:\n",
    "            return interpolation_search(arr,pos+1,hi,x)\n",
    "        \n",
    "        # If x is smaller, x is in left subarray\n",
    "        if arr[pos]>x:\n",
    "            return interpolation_search(arr,lo,pos-1,x)\n",
    "    return -1\n",
    "\n",
    "# Array of items in which\n",
    "# search will be conducted\n",
    "arr = [10, 12, 13, 16, 18, 19, 20,\n",
    "       21, 22, 23, 24, 33, 35, 42, 47]\n",
    "n = len(arr)\n",
    "  \n",
    "# Element to be searched\n",
    "x = 18\n",
    "index = interpolation_search(arr, 0, n - 1, x)\n",
    "  \n",
    "if index != -1:\n",
    "    print(\"Element found at index\", index)\n",
    "else:\n",
    "    print(\"Element not found\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "8131a4d3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Element is present at index 7\n"
     ]
    }
   ],
   "source": [
    "#Exponential Search\n",
    "\n",
    "#binary Search\n",
    "def rec_bin(arr,lo,hi,x):\n",
    "    if(hi>=lo):    #we dont need while as we are recusing the pgm\n",
    "        #value of middle \n",
    "        mid=(lo+hi)//2\n",
    "        \n",
    "        if arr[mid]==x:\n",
    "            return mid\n",
    "        #x is smaller and lies in left side of arr\n",
    "        elif arr[mid]>x:\n",
    "            return rec_bin(arr,lo,mid-1,x)\n",
    "        \n",
    "        #x is larger and lies in right side of arr\n",
    "        else:\n",
    "            return rec_bin(arr,mid+1,hi,x)\n",
    "    return -1\n",
    "\n",
    "#Expoenential search\n",
    "def exponential_search(arr,n,x):\n",
    "    # IF x is present at first \n",
    "    # location itself\n",
    "    if arr[0]==x:\n",
    "        return 0\n",
    "    \n",
    "    # Find range for binary search \n",
    "    # j by repeated doubling\n",
    "    i=1\n",
    "    while i<=n and arr[i]<=x:\n",
    "        #print(i)\n",
    "        i=i*2\n",
    "        \n",
    "    # Call binary search for the found range\n",
    "    return rec_bin(arr,i//2,min(i,n-1),x)\n",
    "\n",
    "# Driver Code\n",
    "arr = [2, 3, 4, 10, 40,50,60,70,80]\n",
    "n = len(arr)\n",
    "x = 70\n",
    "result = exponential_search(arr, n, x)\n",
    "if result == -1:\n",
    "    print (\"Element not found in the array\")\n",
    "else:\n",
    "    print (\"Element is present at index %d\" %(result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "76f5645c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Found at index: 2\n"
     ]
    }
   ],
   "source": [
    "#Fibonacci Search\n",
    "#from bisect import bisect_left\n",
    "\n",
    "def fibMocianSearch(arr,x,n):\n",
    "    fibMM2=0   #(m-2)'th Fibonacci No\n",
    "    fibMM1=1   #(m-1)'th Fibonacci No\n",
    "    fibMM=fibMM2+fibMM1\n",
    "    \n",
    "    # fibM is going to store the smallest\n",
    "    # Fibonacci Number greater than or equal to n\n",
    "    while(fibMM < n):\n",
    "        fibMM2=fibMM1\n",
    "        fibMM1=fibMM\n",
    "        fibMM=fibMM2+fibMM1\n",
    "        \n",
    "    # Marks the eliminated range from front\n",
    "    offset=-1\n",
    "    \n",
    "    while (fibMM>1):\n",
    "        # Check if fibMm2 is a valid location\n",
    "        i=min(offset+fibMM2,n-1)\n",
    "        \n",
    "        # If x is greater than the value at\n",
    "        # index fibMm2, cut the subarray array\n",
    "        # from offset to i\n",
    "        if arr[i]<x:\n",
    "            fibMM=fibMM1\n",
    "            fibMM1=fibMM2\n",
    "            fibMM2=fibMM-fibMM1\n",
    "            offset=i\n",
    "        \n",
    "        # If x is less than the value at\n",
    "        # index fibMm2, cut the subarray\n",
    "        # after i+1\n",
    "        elif arr[i]>x:\n",
    "            fibMM=fibMM2\n",
    "            fibMM1=fibMM1-fibMM2\n",
    "            fibMM2=fibMM-fibMM1\n",
    "        \n",
    "        #element found\n",
    "        else:\n",
    "            return i\n",
    "        \n",
    "    # comparing the last element with x */\n",
    "    if fibMMm1 and arr[n-1]==x:\n",
    "        return n-1\n",
    "    else:\n",
    "        return -1\n",
    "    \n",
    "# Driver Code\n",
    "arr = [10, 22, 35, 40, 45, 50,\n",
    "       80, 82, 85, 90, 100,235]\n",
    "n = len(arr)\n",
    "x = 35\n",
    "ind = fibMocianSearch(arr, x, n)\n",
    "if ind>=0:\n",
    "  print(\"Found at index:\",ind)\n",
    "else:\n",
    "  print(x,\"isn't present in the array\");             "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "c8e9d414",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "8\n"
     ]
    }
   ],
   "source": [
    "#Recursive program to linearly search an element in a given array\n",
    "def rec_lin(arr,x,idx):\n",
    "    if arr[idx]==x:\n",
    "        return idx\n",
    "    elif idx==len(arr)-1:\n",
    "        return -1\n",
    "    else:\n",
    "        return rec_lin(arr,x,idx+1)\n",
    "    return -1\n",
    "arr = [2, 3, 4, 10, 40,50,60,70,80]\n",
    "x=80\n",
    "idx=0\n",
    "print(rec_lin(arr,x,idx))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "56d88820",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Element 3 is present at index 4\n"
     ]
    }
   ],
   "source": [
    "#Recursive program to linearly search an element in a given array\n",
    "def rec_lin_search(arr,low,high,x):\n",
    "    if high<low:\n",
    "        return -1\n",
    "    if arr[low]==x:\n",
    "        return l\n",
    "    if arr[high]==x:\n",
    "        return high\n",
    "    return rec_lin_search(arr,low+1,high-1,x)\n",
    "arr = [12, 34, 54, 2, 3]\n",
    "n = len(arr)\n",
    "x = 3\n",
    "index = rec_lin_search(arr, 0, n-1, x)\n",
    "if index != -1:\n",
    "    print (\"Element\", x,\"is present at index %d\" %(index))\n",
    "else:\n",
    "    print (\"Element %d is not present\" %(x))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "1a6b1d50",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n"
     ]
    }
   ],
   "source": [
    "#Date-09/18/22\n",
    "#Recursive function to do substring search\n",
    "text=\"THIS IS A TEST TEXT\"\n",
    "sub_str=\"TEST\"\n",
    "\n",
    "#Thoughts---As this string is not sorted we have to go with linear search\n",
    "\n",
    "def rec_str_search(txt,sub,low,high):\n",
    "    if high<low:\n",
    "        return -1\n",
    "    if txt[low]==sub:\n",
    "        return low\n",
    "    if txt[high]==sub:\n",
    "        return high\n",
    "    return rec_str_search(txt,sub,low+1,high-1)\n",
    "\n",
    "txt=text.split()\n",
    "sub=sub_str\n",
    "low=0\n",
    "high=len(txt)-1\n",
    "print(rec_str_search(txt,sub,low,high))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "5d45d4da",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n",
      "0\n",
      "1\n"
     ]
    }
   ],
   "source": [
    "def exactMatch(txt,pat,txt_idx,pat_idx):\n",
    "    if txt_idx==len(txt) and pat_idx !=len(pat):   #pattern is larger/not matches woth txt\n",
    "        return 0\n",
    "    \n",
    "    # Else If last character of pattern reaches\n",
    "    if pat_idx==len(pat):\n",
    "        return 1\n",
    "    \n",
    "    if txt[txt_idx]==pat[pat_idx]:  #in the process of matching text with pattern\n",
    "        return exactMatch(txt,pat,txt_idx+1,pat_idx+1)\n",
    "    \n",
    "    return 0\n",
    "\n",
    "# This function returns true if 'text' contain 'pat'\n",
    "def contains(txt,pat,txt_idx,pat_idx):\n",
    "    # If last character of text reaches but pattern could not be found\n",
    "    if txt_idx==len(txt):\n",
    "        return 0\n",
    "    \n",
    "    # If current characters of pat and text match\n",
    "    if txt[txt_idx]==pat[pat_idx]:\n",
    "        if exactMatch(txt,pat,txt_idx,pat_idx):\n",
    "            return 1\n",
    "        else:\n",
    "            return contains(txt,pat,txt_idx+1,pat_idx)\n",
    "    \n",
    "    # If current characters of pat and tex don't match\n",
    "    return contains(txt,pat,txt_idx+1,pat_idx)\n",
    "\n",
    "print(contains(\"geeksforgeeks\", \"geeks\", 0, 0))\n",
    "print(contains(\"geeksforgeeks\", \"geeksquiz\", 0, 0))\n",
    "print(contains(\"geeksquizgeeks\", \"quiz\", 0, 0))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "68d43e24",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n"
     ]
    }
   ],
   "source": [
    "def str_search(txt, sub, k):\n",
    "    n = len(txt)\n",
    "    m = len(sub)\n",
    "    if k < n-m+1:\n",
    "        if txt[k:k+m] == sub:\n",
    "            return True\n",
    "        else:\n",
    "            return str_search(txt, sub, k+1)\n",
    " \n",
    "    else:\n",
    "        return False\n",
    " \n",
    " \n",
    "t = 'this is a test text'\n",
    "print(str_search(t, 'test', 0))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "7cf98ce2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The value n where f() becomes positive first is  12.0\n"
     ]
    }
   ],
   "source": [
    "#Unbounded Binary Search \n",
    "\n",
    "#let take sample function that increases monotonically\n",
    "def f(x):\n",
    "    return (x * x - 10 * x - 20)\n",
    "\n",
    "def find_positive():\n",
    "    # When first value itself is positive\n",
    "    if f(0)>0:\n",
    "        return 0\n",
    "    \n",
    "    # Find 'high' for binary search\n",
    "    # by repeated doubling\n",
    "    i=1\n",
    "    while(f(i)<=0):\n",
    "       # print(\"FP\",f(i))\n",
    "        i=i*2\n",
    "        \n",
    "    return binary(i,i/2)\n",
    "\n",
    "# Searches first positive value of\n",
    "# f(i) where low <= i <= high\n",
    "def binary(high,low):\n",
    "    \n",
    "    if high>=low:        \n",
    "        mid=low+(high-low)/2\n",
    "        #print(\"mid\",mid)\n",
    "        \n",
    "        # If f(mid) is greater than 0\n",
    "        # and one of the following two\n",
    "        # conditions is true:\n",
    "        # a) mid is equal to low\n",
    "        # b) f(mid-1) is negative\n",
    "        if (f(mid)>0 and (mid==low  or f(mid-1)<=0)):\n",
    "            return mid\n",
    "        \n",
    "        if f(mid)<=0:\n",
    "            #print(\"f2\")\n",
    "            return binary(high,low+1)\n",
    "        \n",
    "        else:\n",
    "            #print(\"f3\")\n",
    "            return binary(high-1,low)\n",
    "        \n",
    "    return -1\n",
    "\n",
    "print (\"The value n where f() becomes \"+\n",
    "      \"positive first is \", find_positive());   \n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "fd99d63e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Missing number from array is= 8\n"
     ]
    }
   ],
   "source": [
    "#Find the Missing Number\n",
    "arr = [1, 2, 4, 6, 3, 7, 5]\n",
    "N=8\n",
    "\n",
    "#as this is unsorted array go for linear search\n",
    "\n",
    "def miss_num(arr,N):\n",
    "    for i in range(1,N+1):\n",
    "        if i in arr:\n",
    "            continue\n",
    "        else:\n",
    "            return i\n",
    "print(\"Missing number from array is=\",miss_num(arr,N))     \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "1b891d19",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Missing number from array is= 8.0\n"
     ]
    }
   ],
   "source": [
    "#Using summation of first N natural numbers\n",
    "arr = [1, 2, 4, 6, 3, 7, 5]\n",
    "N=8\n",
    "\n",
    "sum_nat_num=(N+1)*N/2\n",
    "\n",
    "miss_num=sum_nat_num-sum(arr)\n",
    "\n",
    "print(\"Missing number from array is=\",miss_num)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "c2341eef",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4\n"
     ]
    }
   ],
   "source": [
    "#Modification for Overflow\n",
    "def get_miss(arr,N):\n",
    "    i,total=0,1\n",
    "    \n",
    "    for i in range(2,N+2):\n",
    "       # print(total,i)\n",
    "        total+=i\n",
    "       # print(arr[i-2])\n",
    "        total-=arr[i-2]\n",
    "        \n",
    "    return total\n",
    "\n",
    "arr = [1, 2, 3, 5]\n",
    "N = len(arr)\n",
    "\n",
    "print(get_miss(arr,N))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "c438bfbd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4\n"
     ]
    }
   ],
   "source": [
    "#Using binary operations\n",
    "def bin_misNum(arr,N):\n",
    "    x1=arr[0]\n",
    "    x2=1\n",
    "    \n",
    "    for i in range(1,N):\n",
    "        x1=x1^arr[i]\n",
    "        \n",
    "    for i in range(2, n + 2):\n",
    "        x2 = x2 ^ i\n",
    " \n",
    "    return x1 ^ x2\n",
    "\n",
    "arr = [1, 2, 3, 5]\n",
    "N = len(arr)\n",
    "\n",
    "print(bin_misNum(arr,N))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "aa1eba08",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4\n"
     ]
    }
   ],
   "source": [
    "#Using Cyclic Sort\n",
    "def cycSort_misNum(arr,n):\n",
    "    i=0\n",
    "    while(i<n):\n",
    "        correctPos=arr[i]-1\n",
    "        if(arr[i]<n and arr[i]!=arr[correctPos]):\n",
    "            arr[i],arr[correctPos]=correctPos[correctPos],arr[i]\n",
    "        else:\n",
    "            i+=1\n",
    "            \n",
    "    for index in range(n) :\n",
    "        if (arr[index] != index + 1) :\n",
    "            return index + 1;\n",
    "             \n",
    "    return n;\n",
    "arr = [ 1, 2, 3, 5 ];\n",
    "N = len(arr);\n",
    "print(cycSort_misNum(arr, N));"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "dbd3798c",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Use elements as Index and mark the visited places as negative\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "fd1b6f43",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2\n"
     ]
    }
   ],
   "source": [
    "#2-Search an element in a sorted and rotated Array\n",
    "#s-find the pivot with linear search then apply binary search\n",
    "\n",
    "#bug01- this does not support non pivoted array\n",
    "\n",
    "arr = [5, 6, 7, 8, 9, 10, 1, 2, 3]\n",
    "#arr = [5, 6, 7, 8, 9, 10]\n",
    "key = 7\n",
    "\n",
    "def lin_search(arr):   #to find pivot \n",
    "    for i in range(len(arr)-1):\n",
    "        if arr[i]>arr[i+1]:\n",
    "            return i\n",
    "    \n",
    "def bin_search(arr,key,low,high):\n",
    "    if high>=low:\n",
    "        mid=low+(high-low)//2\n",
    "        #print(arr[mid])\n",
    "        if arr[mid]==key:\n",
    "            return mid\n",
    "        \n",
    "        if arr[mid]>key:\n",
    "            return bin_search(arr,key,low+1,high)\n",
    "        else:\n",
    "            return bin_search(arr,key,low,high-1)\n",
    "    return -1\n",
    "        \n",
    "def ele_search(arr,key):\n",
    "    idx=lin_search(arr)\n",
    "    #print(idx,arr[idx+1:],len(arr)-idx)\n",
    "    \n",
    "    if bin_search(arr[:idx+1],key,0,idx-1)>-1 :\n",
    "        return bin_search(arr[:idx+1],key,0,idx-1)\n",
    "    \n",
    "    elif bin_search(arr[idx+1:],key,0,len(arr)-idx+1)>-1:\n",
    "        return bin_search(arr[idx+1:],key,0,len(arr)-idx+1) +idx\n",
    "        \n",
    "    return -1\n",
    "    \n",
    "    #return k,l\n",
    "print(ele_search(arr,key))    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "6e3b1bfd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Index of the element is :  8\n"
     ]
    }
   ],
   "source": [
    "#Date-09/19/22\n",
    "def pivotBinarySearch(arr,n,key):\n",
    "    pivot=findPivot(arr,0,n-1)\n",
    "    \n",
    "    #print(pivot)\n",
    "    # If we didn't find a pivot,then array is not rotated at all\n",
    "    if pivot==-1:\n",
    "        return binarySeearch(arr,0,n-1,key)\n",
    "    \n",
    "    # If we found a pivot, then first compare with pivot and then\n",
    "    # search in two subarrays around pivot\n",
    "    if arr[pivot]==key:\n",
    "        return pivot\n",
    "    if arr[0]<=key:#to select right or left side of pivot\n",
    "        #print(key)\n",
    "        return binarySeearch(arr,0,pivot-1,key)  \n",
    "    return binarySeearch(arr,pivot+1,n-1,key)\n",
    "\n",
    "#binary function to search pivot\n",
    "def findPivot(arr,low,high):\n",
    "    if high<low:\n",
    "        return -1\n",
    "    if high==low:\n",
    "        return low\n",
    "    \n",
    "    mid =int((high+low)/2)\n",
    "    \n",
    "    if mid<high and arr[mid]>arr[mid+1]:\n",
    "        return mid\n",
    "    if mid>low and arr[mid]<arr[mid-1]:\n",
    "        return mid\n",
    "    if arr[low]>=arr[mid]:\n",
    "        return findPivot(arr,low,mid-1)\n",
    "    return findPivot(arr,mid+1,high)\n",
    "\n",
    "#binary function to search key\n",
    "def binarySeearch(arr,low,high,key):\n",
    "    #print(high,low)\n",
    "    if high<low:\n",
    "        return -1\n",
    "    \n",
    "    mid=(low+(high))//2\n",
    "    #print(mid)\n",
    "    \n",
    "    if arr[mid]==key:\n",
    "        return mid\n",
    "    if arr[mid]>=key:\n",
    "        return binarySeearch(arr,low,mid-1,key)\n",
    "    return binarySeearch(arr,mid+1,high,key)\n",
    "\n",
    "arr1 = [5, 6, 7, 8, 9, 10, 1, 2, 3]\n",
    "n = len(arr1)\n",
    "key = 3\n",
    "print(\"Index of the element is : \", \\\n",
    "    pivotBinarySearch(arr1, n, key))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "6ee68111",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Index:  4\n"
     ]
    }
   ],
   "source": [
    "#Binary search on Array without finding Pivot\n",
    "def searchKey(arr,lo,hi,key):\n",
    "    if lo>hi:\n",
    "        return -1\n",
    "    \n",
    "    mid=(lo+hi)//2\n",
    "    \n",
    "    if arr[mid]==key:\n",
    "        return mid\n",
    "    \n",
    "    # If arr[lo...mid] is sorted\n",
    "    if arr[lo]<=arr[mid]:\n",
    "        # As this subarray is sorted, we can quickly\n",
    "        # check if key lies in half or other half\n",
    "        if key>arr[lo] and key<=arr[mid]:\n",
    "            return searchKey(arr,lo,mid-1,key)\n",
    "        return searchKey(arr,mid+1,hi,key)\n",
    "    \n",
    "    # If arr[l..mid] is not sorted, then arr[mid... r]\n",
    "    # must be sorted\n",
    "    if key>=arr[mid] and key<=arr[hi]:\n",
    "        return searchKey(arr,mid+1,hi,key)\n",
    "    return searchKey(arr,lo,mid-1,key)\n",
    "\n",
    "#arr = [4, 5, 6, 7, 8, 9, 1, 2, 3]\n",
    "arr = [8,9,1,2,3]\n",
    "key = 3\n",
    "i = searchKey(arr, 0, len(arr)-1, key)\n",
    "if i != -1:\n",
    "    print(\"Index: % d\" % i)\n",
    "else:\n",
    "    print(\"Key not found\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "ef22fca9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "16.0"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#3-Median of two sorted arrays of same size\n",
    "arr1 = [1, 12, 15, 26, 38]\n",
    "arr2 = [2, 13, 17, 30, 45]\n",
    "\n",
    "#s1-merge 2 array sorted way. find median\n",
    "#s2-see whats the length of the array and find middle index. if length is odd/even then find the middle indexes accordingly\n",
    "\n",
    "#bug1-I did not consider sorting after merging \n",
    "#bug2-did not consider the common elemnets\n",
    "\n",
    "def arr_med(arr1,arr2):\n",
    "    l=len(arr1)\n",
    "    if l%2==1:\n",
    "        med1=arr1[l//2]\n",
    "        med2=arr2[l//2]\n",
    "        med=(med1+med2)/2\n",
    "        \n",
    "    elif l%2==0:\n",
    "        med1=arr1[(l//2)-1:(l//2)+1]\n",
    "        #print(med1)\n",
    "        med2=arr2[(l//2)-1:(l//2)+1]\n",
    "        med=(sum(med1)+sum(med2))/2\n",
    "\n",
    "    return med\n",
    "\n",
    "arr_med(arr1,arr2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "dce6dd45",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Median is  16.0\n"
     ]
    }
   ],
   "source": [
    "#count while Merging\n",
    "def median(ar1,ar2,n):\n",
    "    i=0 # Current index of i/p list ar1[]\n",
    "    j=0 # Current index of i/p list ar2[]\n",
    "    \n",
    "    m1=-1\n",
    "    m2=-1\n",
    "    \n",
    "    # Since there are 2n elements, median\n",
    "    # will be average of elements at index\n",
    "    # n-1 and n in the array obtained after\n",
    "    # merging ar1 and ar2\n",
    "    count=0\n",
    "    \n",
    "    while count<n+1:\n",
    "        count+=1\n",
    "        \n",
    "        # Below is to handle case where all\n",
    "        # elements of ar1[] are smaller than\n",
    "        # smallest(or first) element of ar2[]\n",
    "        if i==n:\n",
    "            m1=m2\n",
    "            m2=ar2[0]\n",
    "            break\n",
    "        \n",
    "        # Below is to handle case where all \n",
    "        # elements of ar2[] are smaller than\n",
    "        # smallest(or first) element of ar1[]\n",
    "        if j==n:\n",
    "            m1==m2\n",
    "            m2=ar1[0]\n",
    "            break\n",
    "            \n",
    "        # equals sign because if two \n",
    "        # arrays have some common elements\n",
    "        if ar1[i]<=ar2[j]:\n",
    "            m1=m2\n",
    "            m2=ar1[i]\n",
    "            i+=1\n",
    "            \n",
    "        else:\n",
    "            m1=m2\n",
    "            m2=ar2[j]\n",
    "            j+=1\n",
    "            \n",
    "    return (m1+m2)/2\n",
    "\n",
    "ar1 = [1, 12, 15, 26, 38]\n",
    "ar2 = [2, 13, 17, 30, 45]\n",
    "n1 = len(ar1)\n",
    "n2 = len(ar2)\n",
    "if n1 == n2:\n",
    "    print(\"Median is \", median(ar1, ar2, n1))\n",
    "else:\n",
    "    print(\"Doesn't work for arrays of unequal size\")\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "b8bc4422",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5\n"
     ]
    }
   ],
   "source": [
    "#comparing the medians of two array\n",
    "\n",
    "#condition len(arr1)=len(arr2)=n\n",
    "def getMedian(arr1, arr2, n): \n",
    "      \n",
    "    # there is no element in any array\n",
    "    if n == 0: \n",
    "        return -1\n",
    "          \n",
    "    # 1 element in each => median of \n",
    "    # sorted arr made of two arrays will    \n",
    "    elif n == 1: \n",
    "        # be sum of both elements by 2\n",
    "        return (arr1[0]+arr2[0])/2\n",
    "          \n",
    "    # Eg. [1,4] , [6,10] => [1, 4, 6, 10]\n",
    "    # median = (6+4)/2    \n",
    "    elif n == 2: \n",
    "        # which implies median = (max(arr1[0],\n",
    "        # arr2[0])+min(arr1[1],arr2[1]))/2\n",
    "        return (max(arr1[0], arr2[0]) + \n",
    "                min(arr1[1], arr2[1])) / 2\n",
    "      \n",
    "    else:\n",
    "        #calculating medians     \n",
    "        m1 = median(arr1, n)\n",
    "        m2 = median(arr2, n)\n",
    "          \n",
    "        # then the elements at median \n",
    "        # position must be between the \n",
    "        # greater median and the first \n",
    "        # element of respective array and \n",
    "        # between the other median and \n",
    "        # the last element in its respective array.\n",
    "        if m1 > m2:\n",
    "              \n",
    "            if n % 2 == 0:\n",
    "                return getMedian(arr1[:(n // 2) + 1],\n",
    "                        arr2[int(n / 2) - 1:], int(n / 2) + 1)\n",
    "            else:\n",
    "                return getMedian(arr1[:int(n / 2) + 1], \n",
    "                        arr2[int(n / 2):], int(n / 2) + 1)\n",
    "          \n",
    "        else:\n",
    "            if n % 2 == 0:\n",
    "                return getMedian(arr1[int(n / 2 - 1):],\n",
    "                        arr2[:(n // 2 + 1)], int(n / 2) + 1)\n",
    "            else:\n",
    "                return getMedian(arr1[int(n / 2):], \n",
    "                        arr2[0:int(n / 2) + 1], int(n / 2) + 1)\n",
    "  \n",
    " # function to find median of array\n",
    "def median(arr, n):\n",
    "    if n % 2 == 0:\n",
    "        return (arr[int(n / 2)] +\n",
    "                arr[int(n / 2) - 1]) / 2\n",
    "    else:\n",
    "        return arr[int(n/2)]\n",
    "  \n",
    "      \n",
    "# Driver code\n",
    "arr1 = [1, 2, 3, 6]\n",
    "arr2 = [4, 6, 8, 10]\n",
    "n = len(arr1)\n",
    "print(int(getMedian(arr1,arr2,n)))  \n",
    "            "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "ec5305e4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Median is 16.0\n"
     ]
    }
   ],
   "source": [
    "#Merging two arrays w/o extra space\n",
    "def getmedian(ar1,ar2,n):\n",
    "    i,j=n-1,0  #i from end and j from 0\n",
    "    \n",
    "    # while loop to swap all smaller numbers to arr1\n",
    "    while(arr1[i]>arr2[j] and i>-1 and j<n):\n",
    "        ar1[i],ar2[j]=ar2[j],ar1[i]\n",
    "        i-=1\n",
    "        j+=1\n",
    "        \n",
    "    ar1.sort()\n",
    "    ar2.sort()\n",
    "    \n",
    "    return (ar1[-1],ar2[0])>>1  #this is basically ==(ar1[-1],ar2[0])/2\n",
    "\n",
    "ar1 = [1, 12, 15, 26, 38]\n",
    "ar2 = [2, 13, 17, 30, 45]\n",
    "  \n",
    "n1, n2 = len(ar1), len(ar2)\n",
    "  \n",
    "if(n1 == n2):\n",
    "    print('Median is', getMedian(ar1, ar2, n1))\n",
    "else:\n",
    "    print(\"Doesn't work for arrays of unequal size\")\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "40f4a485",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a >> 1 = 3\n",
      "b >> 1 = -5\n",
      "a << 1 = 12\n",
      "b << 1 = -20\n"
     ]
    }
   ],
   "source": [
    "#bitwise operator magic\n",
    "a = 6\n",
    "b = -10\n",
    " \n",
    "# print bitwise right shift operator\n",
    "print(\"a >> 1 =\", a >> 1)\n",
    "print(\"b >> 1 =\", b >> 1)\n",
    " \n",
    "a = 6\n",
    "b = -10\n",
    " \n",
    "# print bitwise left shift operator\n",
    "print(\"a << 1 =\", a << 1)\n",
    "print(\"b << 1 =\", b << 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "ee99622b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-80, -10, 1, 60, 70, 85]\n",
      "71\n"
     ]
    }
   ],
   "source": [
    "#4-Two elements whose sum is closest to zero\n",
    "#Desc-An Array of integers is given, both +ve and -ve. find the two elements that their sum is closest to zero.\n",
    "\n",
    "#s1->naive- addition of two elements with 2 for loops and compare them. both elements could be +ve or -ve or opposite signed\n",
    "#s2->sort array and add two middle elements as they are closet to zero\n",
    "\n",
    "#s2-  \n",
    "#bug-will work only when we have equal num of +ve and -ve nums equally distributed\n",
    "arr=[1, 60, -10, 70, -80, 85]\n",
    "\n",
    "def zeroNear_sum(arr):\n",
    "    l=len(arr)\n",
    "    sorted_arr=sorted(arr)\n",
    "    print(sorted_arr)\n",
    "    if l%2==0:\n",
    "        res=sorted_arr[(l//2)-1]+sorted_arr[(l//2)+1]\n",
    "    else:\n",
    "        res=min((sorted_arr[(l//2)-1]+sorted_arr[(l//2)]),(sorted_arr[(l//2)]+sorted_arr[(l//2)+1]))\n",
    "    \n",
    "    return res\n",
    "print(zeroNear_sum(arr))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "2820e80e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The two elements whose sum is minimum are -80 and  85\n"
     ]
    }
   ],
   "source": [
    "##s1->naive- addition of two elements with 2 for loops and compare them\n",
    "#this is incorrect solution\n",
    "def minSumPair(arr,arr_size):\n",
    "    inv_cnt=0\n",
    "    \n",
    "    # Array should have at least\n",
    "    # two elements\n",
    "    if arr_size<2:\n",
    "        print(\"invalid input\")\n",
    "        return -1\n",
    "    \n",
    "    # Initialization of values\n",
    "    min_l=0\n",
    "    min_r=1\n",
    "    min_sum=arr[0]+arr[1]\n",
    "    \n",
    "    for l in range(arr_size-1):\n",
    "        for r in range(l+1,arr_size):\n",
    "            sum=arr[l]+arr[r]\n",
    "            if abs(min_sum)>abs(sum):\n",
    "                min_sum=sum\n",
    "                min_l=l\n",
    "                min_r=r\n",
    "    print(\"The two elements whose sum is minimum are\",\n",
    "            arr[min_l], \"and \", arr[min_r])\n",
    "arr = [1, 60, -10, 70, -80, 85]\n",
    " \n",
    "minSumPair(arr, 6);\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "bd7284ce",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The two elements whose sum is minimum are 85 and -80\n"
     ]
    }
   ],
   "source": [
    "#sorting \n",
    "\n",
    "#sort funnction\n",
    "# arr[] --> Array to be sorted\n",
    "# si --> Starting index\n",
    "# ei --> Ending index\n",
    "def partition(arr,si,ei):\n",
    "    x=arr[ei]\n",
    "    i=(si-1)\n",
    "    \n",
    "    for j in range(si,ei):\n",
    "        if arr[j]<=x:\n",
    "            i++1\n",
    "            arr[i],arr[j]=arr[j],arr[i]\n",
    "    arr[i+1],arr[ei]=arr[ei],arr[i+1]\n",
    "    return (i+1)\n",
    "\n",
    "#quick sort\n",
    "def quickSort(arr,si,ei):\n",
    "    pi=0 # Partitioning index */\n",
    "    if (si<ei):\n",
    "        pi=partition(arr,si,ei)\n",
    "        quickSort(arr,si,pi-1)\n",
    "        quickSort(arr,pi+1,ei)\n",
    "        \n",
    "def minAbsSumPair(arr,n):\n",
    "    # Variables to keep track\n",
    "    # of current sum and minimum sum\n",
    "    sum,min_sum=0,10**5\n",
    "    \n",
    "    #left and right index vars\n",
    "    l=0\n",
    "    r=n-1\n",
    "    \n",
    "    # variable to keep track of\n",
    "    # the left and right pair for min_sum\n",
    "    min_l=l\n",
    "    min_r=n-1\n",
    "    \n",
    "    #array should have a least 2 elements\n",
    "    if (n<2):\n",
    "        print(\"invlid input\")\n",
    "        return\n",
    "    # Sort the elements */\n",
    "    quickSort(arr,l,r)\n",
    "    \n",
    "    while(l<r):\n",
    "        sum=arr[l]+arr[r]\n",
    "        \n",
    "        # If abs(sum) is less\n",
    "        # then update the result items\n",
    "        if (abs(sum)<abs(min_sum)):\n",
    "            min_sum=sum\n",
    "            min_l=l\n",
    "            min_r=r\n",
    "        if sum<0:\n",
    "            l+=1\n",
    "        else:\n",
    "            r-=1\n",
    "    print(\"The two elements whose sum is minimum are\",\n",
    "                        arr[min_l], \"and\", arr[min_r])\n",
    "arr = [1, 60, -10, 70, -80, 85]\n",
    "n = len(arr)\n",
    "minAbsSumPair(arr, n)  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "1b2b2987",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The two elements whose sum is minimum are -80 and 81\n"
     ]
    }
   ],
   "source": [
    "#using STL\n",
    "import sys\n",
    "\n",
    "def findMinSum(arr,n):\n",
    "    for i in range(1,n):\n",
    "        # Modified to sort by absolute values\n",
    "        if (not abs(arr[i-1])<abs(arr[i])):\n",
    "            arr[i-1],arr[i]=arr[i],arr[i-1]\n",
    "    Min=sys.maxsize\n",
    "    x=0\n",
    "    y=0\n",
    "    \n",
    "    for i in range(1,n):\n",
    "        # Absolute value shows how\n",
    "        # close it is to zero\n",
    "        if (abs(arr[i-1]+arr[i])<Min):\n",
    "            # If found an even close value\n",
    "            # update min and store the index\n",
    "            Min=abs(arr[i-1]+arr[i])\n",
    "            x=i-1\n",
    "            y=i\n",
    "    print(\"The two elements whose sum is minimum are\",\n",
    "          arr[x], \"and\", arr[y])\n",
    " \n",
    "# Driver code\n",
    "arr = [ 1, 60, -10, 81, -80, 85 ]\n",
    "n = len(arr)\n",
    "findMinSum(arr, n)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "2115ef7a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(1, 10)\n"
     ]
    }
   ],
   "source": [
    "#5-Find the smallest and second smallest elements in an array\n",
    "#s1-sort array and get 1st and second element\n",
    "#s2-Linear search min and sec min finding\n",
    "\n",
    "#s2-\n",
    "arr = [12, 13, 1, 10, 34, 1 ]\n",
    "\n",
    "def linear_srch(arr):\n",
    "    min_el=arr[0]\n",
    "    sec_min_el=arr[1]\n",
    "    \n",
    "    for i in arr:\n",
    "        if i<min_el:\n",
    "            #sec_min_el=min_el\n",
    "            min_el=i\n",
    "    for i in arr:      \n",
    "        if i<sec_min_el and i>min_el:\n",
    "            sec_min_el=i\n",
    "    return min_el,sec_min_el\n",
    "\n",
    "print(linear_srch(arr))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "6dd327f8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 10\n"
     ]
    }
   ],
   "source": [
    "#s1-sorting\n",
    "arr = [12, 13, 1, 10, 34]\n",
    "arr.sort()\n",
    "\n",
    "print(arr[0],arr[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "7fe5de8d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The smallest element is 1 and  second smallest element is 10\n"
     ]
    }
   ],
   "source": [
    "#S3-STL\n",
    "import math\n",
    "def printToSmallest(arr):\n",
    "    # There should be atleast two elements\n",
    "    arr_size=len(arr)\n",
    "    if arr_size<2:\n",
    "        print(\"Invalid Input\")\n",
    "        return\n",
    "    first=second=math.inf\n",
    "    \n",
    "    for i in range(0,arr_size):\n",
    "        # If current element is smaller than first then\n",
    "        # update both first and second\n",
    "        if arr[i]<first:\n",
    "            second=first\n",
    "            first=arr[i]\n",
    "            \n",
    "        # If arr[i] is in between first and second then\n",
    "        # update secon\n",
    "        elif arr[i]<second and arr[i]!=first:\n",
    "            second=arr[i]\n",
    "    if (second == math.inf):\n",
    "        print (\"No second smallest element\")\n",
    "    else:\n",
    "        print ('The smallest element is',first,'and', \\\n",
    "              ' second smallest element is',second)\n",
    " \n",
    "# Driver function to test above function\n",
    "arr = [12, 13, 1, 10, 34, 1]\n",
    "printToSmallest(arr)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "5dfc2f5c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 9\n"
     ]
    }
   ],
   "source": [
    "#6-Maximum and minimum of an array using minimum number of comparisons\n",
    "#s1-sort and arr[0] and arr[-1]\n",
    "#s2-max and min functions\n",
    "\n",
    "arr=[3, 5, 4, 1, 9]\n",
    "arr.sort()\n",
    "\n",
    "print(arr[0],arr[-1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "7587daba",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Minimum element is 1\n",
      "Maximum element is 3000\n"
     ]
    }
   ],
   "source": [
    "#linear search\n",
    "# structure is used to return two values from minMax()\n",
    "class pair:\n",
    "    def __init__(self):\n",
    "        self.min=0\n",
    "        self.max=0\n",
    "    \n",
    "def getMinMax(arr:list,n:int) ->pair:\n",
    "    minmax=pair()\n",
    "    \n",
    "    # If there is only one element then return it as min and max both\n",
    "    if n==1:\n",
    "        minmax.max=arr[0]\n",
    "        minmax.min=arr[0]\n",
    "        \n",
    "    # If there are more than one elements, then initialize min\n",
    "    # and max\n",
    "    if arr[0]>arr[1]:\n",
    "        minmax.max=arr[0]\n",
    "        minmax.min=arr[1]\n",
    "    else:\n",
    "        minmax.max=arr[1]\n",
    "        minmax.min=arr[0]\n",
    "        \n",
    "    for i in range(2,n):\n",
    "        if arr[i]>minmax.max:\n",
    "            minmax.max=arr[i]\n",
    "        elif arr[i]<minmax.min:\n",
    "            minmax.min=arr[i]\n",
    "    return minmax\n",
    "\n",
    "arr = [1000, 11, 445, 1, 330, 3000]\n",
    "arr_size = 6\n",
    "minmax = getMinMax(arr, arr_size)\n",
    "print(\"Minimum element is\", minmax.min)\n",
    "print(\"Maximum element is\", minmax.max)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "52b9864d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Minimum element is  1\n",
      "nMaximum element is  3000\n"
     ]
    }
   ],
   "source": [
    "#tournament method\n",
    "def getMinmax(low,high,arr):\n",
    "    arr_max=arr[low]\n",
    "    arr_min=arr[low]\n",
    "    \n",
    "    # If there is only one element\n",
    "    if low==high:\n",
    "        arr_max=arr[low]\n",
    "        arr_min=arr[low]\n",
    "        return (arr_max,arr_min)\n",
    "    \n",
    "    # If there is only two element\n",
    "    elif high==low+1:\n",
    "        if arr[low]>arr[high]:\n",
    "            arr_max=arr[low]\n",
    "            arr_min=arr[high]\n",
    "        else:\n",
    "            arr_min=arr[low]\n",
    "            arr_max=arr[high]\n",
    "        return (arr_max,arr_min)\n",
    "    else:\n",
    "        # If there are more than 2 elements\n",
    "        mid=(low+high)//2\n",
    "        arr_max1,arr_min1=getMinmax(low,mid,arr)\n",
    "        arr_max2,arr_min2=getMinmax(mid+1,high,arr)\n",
    "    \n",
    "    return (max(arr_max1, arr_max2), min(arr_min1, arr_min2))\n",
    "\n",
    "arr = [1000, 11, 445, 1, 330, 3000]\n",
    "high = len(arr) - 1\n",
    "low = 0\n",
    "arr_max, arr_min = getMinmax(low, high, arr)\n",
    "print('Minimum element is ', arr_min)\n",
    "print('nMaximum element is ', arr_max)        \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "d66b0989",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Minimum element is 1\n",
      "Maximum element is 3000\n"
     ]
    }
   ],
   "source": [
    "#comparing in pairs\n",
    "def minMax(arr):\n",
    "    n=len(arr)\n",
    "    \n",
    "    # If array has even number of elements then\n",
    "    # initialize the first two elements as minimum\n",
    "    # and maximum\n",
    "    if (n%2==0):\n",
    "        mx=max(arr[0],arr[1])\n",
    "        mn=min(arr[0],arr[1])\n",
    "        \n",
    "        # set the starting index for loop\n",
    "        i=2\n",
    "    # If array has odd number of elements then\n",
    "    # initialize the first element as minimum\n",
    "    # and maximum\n",
    "    else:\n",
    "        mx=mn=arr[0]\n",
    "        i=1\n",
    "        \n",
    "    # In the while loop, pick elements in pair and\n",
    "    # compare the pair with max and min so far\n",
    "    while(i<n-1):\n",
    "        if arr[i]<arr[i+1]:\n",
    "            mx=max(mx,arr[i+1])\n",
    "            mn=min(mn,arr[i])\n",
    "        else:\n",
    "            mx=max(mx,arr[i])\n",
    "            mn=min(mn,arr[i+1])            \n",
    "        i+=2\n",
    "        \n",
    "    return (mx,mn)\n",
    "arr = [1000, 11, 445, 1, 330, 3000]\n",
    "mx, mn = minMax(arr)\n",
    "print(\"Minimum element is\", mn)\n",
    "print(\"Maximum element is\", mx)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "99ac573a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[50, 30, 23]\n"
     ]
    }
   ],
   "source": [
    "#7-k largest(or smallest) elements in an array\n",
    "#s1-sort arr and last three elements\n",
    "#s2-using temp arr where 1,2,3 position will be for largest,larger and large elements\n",
    "\n",
    "arr=[1, 23, 12, 9, 30, 2, 50]\n",
    "n_largest=3\n",
    "\n",
    "def kLrgest(arr):\n",
    "    res=[0,0,0]\n",
    "    \n",
    "    for i in arr:\n",
    "        if i>res[0]:\n",
    "            res[2]=res[1]\n",
    "            res[1]=res[0]\n",
    "            res[0]=i\n",
    "        elif i<res[0] and i>res[1]:\n",
    "            res[2]=res[1]\n",
    "            res[1]=i\n",
    "        elif i<res[1] and i>res[2]:\n",
    "            res[2]=i\n",
    "    return res\n",
    "print(kLrgest(arr))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "50c04ba8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "50 30 23 "
     ]
    }
   ],
   "source": [
    "#use sorting\n",
    "def kLargest(arr, k):\n",
    "    # Sort the given array arr in reverse\n",
    "    # order.\n",
    "    arr.sort(reverse = True)\n",
    "    # Print the first kth largest elements\n",
    "    for i in range(k):\n",
    "        print (arr[i], end =\" \")\n",
    " \n",
    "# Driver program\n",
    "arr = [1, 23, 12, 9, 30, 2, 50]\n",
    "# n = len(arr)\n",
    "k = 3\n",
    "kLargest(arr, k)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "97f68d88",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
